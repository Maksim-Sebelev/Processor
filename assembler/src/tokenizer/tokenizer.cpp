#include <assert.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include "tokenizer/tokenizer.hpp"
#include "global/global_include.hpp"
#include "functions_for_files/files.hpp"
#include "lib/lib.hpp"

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


static Token*       TokensCalloc      (size_t buffer_len);

static bool         GetCmdFlag        (const char* word, const char* command, size_t command_len);

static Cmd          HandleCmd         (const char* word);
static Registers    HandleRegister    (const char* word);
static Number       HandleNumber      (const char* word);
static Bracket      HandleBracket     (const char* word);
static Separator    HandleSeparator   (const char* word);
static MathOperator HandleMathOperator(const char* word);

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

struct Pointers
{
    size_t ip; // input pointer
    size_t tp; // token pointer
    size_t lp; // line pointer (line in input file)
    size_t sp; // str pointer (pos in line)
};

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TokensArray GetTokensArray(const char* asm_file)
{
    assert(asm_file);

    size_t      buffer_size = 0;
    const char* buffer      = ReadFileInBuffer(asm_file, &buffer_size);

    Token* tokens_array = TokensCalloc(buffer_size);

    Pointers pointer = {0, 0, 1, 1};


    while (pointer.ip < buffer_size)
    {
        while (pointer.ip < buffer_size && IsPassSymbol(buffer[pointer.ip]))
        {
            char tmp = buffer[pointer.ip];

            if      (IsSpace  (tmp)) UpdatePointersAfterSpace  (&pointer);
            else if (IsSlashN (tmp)) UpdatePointersAfterSlashN (&pointer);
            else                     assert(0 && "Something went wrong :(");
        }

        const char* word     = buffer + pointer.ip;
        size_t      wordSize = 0;

        if (IsSlash0(word[0])) break;

        if (HandleComment(word, &pointer))
            continue;
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static Token* TokensCalloc(size_t buffer_len)
{
    Token* tokens_array = (Token*) calloc(buffer_len + 1, sizeof(*tokens_array));
    
    if (!tokens_array)
        EXIT(EXIT_FAILURE, "failed allocate memory for tokens array.");

    return tokens_array;
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// enum class TokenType
// {
//     token_command       ,
//     token_register      ,
//     token_number        ,
//     token_bracket       ,
//     token_separator     ,
//     token_math_operation,
// };


//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool GetCmdFlag(const char* word, const char* command, size_t command_len)
{
    assert(word);
    assert(command);

    return  (strncmp(word, command, command_len) == 0) &&
            (word[command_len + 1] == ' ');
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static Cmd HandleCmd(const char* word)
{
    assert(word);

    for (size_t i = 0; i < CmdInfoArrSize; i++)
    {
        CmdInfo cmd = CmdInfoArr[i];
    
        if (GetCmdFlag(word, cmd.name, cmd.nameLen))
            return cmd.cmd;
    }

    return Cmd::undef_cmd;
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static Registers HandleRegister(const char* word)
{
    assert(word);

    const char w0 = word[0];
    const char w1 = word[1];

    bool flag = (word[1] == 'x') &&
                ('a' <= word[0] && word[0] <= 'a' + REGISTERS_QUANT);

    if (flag)
        return  (Registers) (w1 - 'a');

    return Registers::undef_register;
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static Number HandleNumber(const char* word)
{
    assert(word);

    size_t number_len = 0;

    for (number_len = 0; isdigit(word[number_len]); number_len++);

    Number number = {.number = word, .number_len = number_len};

    return number;
};

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static Bracket HandleBracket(const char* word)
{
    assert(word);

    const char w0 = word[0];

    if (w0 == (char) Bracket::left_bracket)
        return Bracket::left_bracket;
    
    if (w0 == (char) Bracket::right_bracket)
        return Bracket::right_bracket;

    return Bracket::undef_bracket;
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static Separator HandleSeparator(const char* word)
{
    assert(word);

    const char w0 = word[0];

    if (w0 == (char) Separator::comma)
        return Separator::comma;

    if (w0 == (char) Separator::colon)
        return Separator::colon;

    return Separator::undef_separator;
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static MathOperator HandleMathOperator(const char* word)
{
    assert(word);

    const char w0 = word[0];

    if (w0 == (char) MathOperator::plus)
        return MathOperator::plus;

    return MathOperator::undef_operator;
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static TokenizerLabel HandleLabel(const char* word)
{
    assert(word);

    size_t name_len = 0;

    if (IsPointSymbol(word[0]) && !(IsLetterSymbol(word[1]) || IsNumSymbol(word[1])))
        return {};

    if (IsPointSymbol(word[0]))
        name_len++;

    size_t i = name_len;

    for (; IsLetterOrNumberOrUnderLineSymbol(word[i]) && word[i] != (char) Separator::colon; i++);

    name_len = i;

    TokenizerLabel label = {.label = word, .label_len = name_len};

    return label;
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool HandleComment(const char* word, )

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool IsNumSymbol(char c)
{
    return  ('0' <= c  ) && 
            (c   <= '9');
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool IsPointSymbol(char c)
{
    return (c == '.');
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool IsLetterSymbol(char c)
{
    return  ('a' <= c && c <= 'z') ||
            ('A' <= c && c <= 'Z');
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool IsUnderLineSymbol(char c)
{
    return (c == '_');
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool IsLetterOrUnderLineSymbol(char c)
{
    return  IsLetterSymbol   (c) ||
            IsUnderLineSymbol(c);
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool IsLetterOrNumberOrUnderLineSymbol(char c)
{
    return  IsLetterSymbol    (c) ||
            IsUnderLineSymbol (c) ||
            IsNumSymbol       (c);
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool IsSpace(char c)
{
    return (c == ' ');
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool IsSlashN(char c)
{
    return (c == '\n');
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool IsSlash0(char c)
{
    return (c == '\0');
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool IsSlashNOrSlashN(char c)
{
    return  IsSlashN(c) ||
            IsSlash0(c);
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static bool IsPassSymbol(char c)
{
    return (IsSpace  (c) ||
            IsSlashN (c));
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static void UpdatePointersAfterSpace(Pointers* pointer)
{
    assert(pointer);

    pointer->ip++;
    pointer->sp++;

    return;
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

static void UpdatePointersAfterSlashN(Pointers* pointer)
{
    assert(pointer);

    pointer->ip++;
    pointer->lp++;
    pointer->sp = 1;

    return;
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
